<!doctype html>
<html>
    <head>
        <script src="./script.js" type="module"></script>
        <style>
            code {
                background:#ddd;
                padding:0 4px;
                border-radius:.5em;
            }
            .cell {
                padding: 1em;
                border: solid 1px #aaa;
                margin: 2rem 0;
            }
            [data-tbd] {
                color:#aaa;
            }
        </style>
        <title>Ethereum LevelDB Explorer</title>
    </head>
    <body style="margin:0 max(100px, 20%);margin-bottom:300px; font-family:sans-serif;">
        <h1>Ethereum LevelDB Explorer</h1>
        <p>
            <a href="https://github.com/Tudmotu/leveldb-explorer" target=_blank>Github repository - contributions are welcome</a>
        </p>
        <details>
            <summary>About this tool</summary>
            <p>
                The purpose of this tool is to be an educational resource for people
                trying to learn about Ethereum's data storage. This tool assumes
                deep understanding of how Ethereum's data looks like. If you ever
                wondered how Ethereum stores its blockchain data, this tool is for
                you.
            </p>
            <p>
                This tool is based on the Geth implementation using LevelDB.<br>
                Since the Yellow Paper never provided an actual implementation,
                different clients implement the Ethereum database differently,
                but because of the use of very specific mathematical concepts,
                most clients implement the database very similarly.
            </p>
            <p>
                Generally speaking, Ethereum saves all of its data in a simple
                key/value store. But how would you save complex data structures such
                as blocks and transactions in a flat key/value store? Ethereum employes
                several different serialization techniques in order to achieve
                this.<br>
                For more information about these data structures, refer to the
                following resources:
                <ul>
                    <li>
                        <a
                            href="https://medium.com/coinmonks/data-structure-in-ethereum-episode-4-diving-by-examples-f6a4cbd8c329" target=_blank>
                            Data structure in Ethereum | Episode 4: Diving into examples
                        </a>
                    </li>
                    <li>
                        <a href="https://ethereum.stackexchange.com/questions/57883/how-the-blocks-and-tries-are-stored" target=_blank>
                            How the blocks and tries are stored, Ethereum StackExchange
                        </a>
                    </li>
                    <li>
                        <a href="https://etherworld.co/2019/02/06/reading-ethereum-geth-database-leveldb/" target=_blank>
                            Reading Ethereum Geth database (LEVELDB)
                        </a>
                    </li>
                    <li>
                        <a href="https://medium.com/shyft-network/understanding-trie-databases-in-ethereum-9f03d2c3325d" target=_blank>
                            Understanding Trie Databases in Ethereum
                        </a>
                    </li>
                </ul>
                This tool works with the Sepolia testnet and is currently updated
                until block <code id="lastBlock"></code>. To confirm the results you get from this tool, you
                can cross-check them on <a href="https://sepolia.etherscan.io/" target=_blank>Etherscan</a>.<br>
                With this tool you can manually explore the LevelDB data by querying
                specific keys. It's as low-level as possible, since its main
                purpose is educational.<br>
                All the data, both keys and values, is saved in a binary format.
                This tool accepts and responds with hex-encoded binary data.
            </p>
            <p>
                The decoding scheme of the results that come from the LevelDB is
                beyond the scope of this text, but this tool provides several
                decoders that let you decode the results in different ways.
                Different values require different decoders &mdash; make sure
                you use the appropriate decoder for each piece of data.
            </p>
        </details>
        <details>
            <summary>LevelDB keys</summary>
            <p>
                Ethereum stores several top-level keys with mutable values:
                <ul>
                    <li>LastBlock (in hex: <code>4c617374426c6f636b</code>)</li>
                    <li>LastHeader (in hex: <code>4c617374486561646572</code>)</li>
                    <li>LastFast (in hex: <code>4c61737446617374</code>)</li>
                    <li>DatabaseVersion (in hex: <code>446174616261736556657273696f6e</code>)</li>
                </ul>

                Keys relating to parsing blocks are constructed using different
                prefixes &amp; suffixes. These are:
                <ul>
                    <li><code>68</code> ("h")</li>
                    <li><code>48</code> ("H")</li>
                    <li><code>6e</code> ("n")</li>
                    <li><code>62</code> ("b")</li>
                    <li><code>74</code> ("t")</li>
                    <li><code>72</code> ("r")</li>
                    <li><code>42</code> ("B")</li>
                </ul>

                The rest of the keys that are stored in the DB are hashes that
                comprise different Merkle tries. More on that below.
            </p>
        </details>
        <details>
            <summary>Retrieving Block Data</summary>
            <p>
                Retrieving block data requires using the block number and/or
                hash in order to construct the keys that hold the data that we
                want.
            </p>
            <p>
                <h4>Example - Retrieving block headers</h4>
                To find a block hash by its number, you would concatenate the "h"
                prefix (<code>68</code>) and the "n" suffix (<code>6e</code>). Once
                you find the block hash, you can retrieve its header data.<br>
                To find the header data, you would concatenate the "h" prefix
                (<code>68</code>) with the block number (in hex and padded to 16
                digits) and the block hash.<br><br>

                Let's take block number 2,505,997 as an example
                <ul>
                    <li>
                        In hex, the number is <code>263d0d</code>. Padded to 16
                        digits: <code>0000000000263d0d</code>
                    </li>
                    <li>
                        To find the block hash, we query for
                        <code><b>68</b>0000000000263d0d<b>6e</b></code>
                    </li>
                    <li>
                        Then we take the result
                        (<code>9d32afbe77c7d105253b4ed7750caf23063352936ce357b89a9dd54c9fa24ab1</code>)
                        and use the "h" prefix along with the block number and
                        the hash to find the block header:
                        <code><b>68</b>0000000000263d0d9d32afbe77c7d105253b4ed7750caf23063352936ce357b89a9dd54c9fa24ab1</code>
                    </li>
                </ul>
                We can use the "Block Header" decoder to parse the result into
                the different fields of the header. Of these fields, notable
                are:
                <ul>
                    <li><code>stateRoot</code></li>
                    <li><code>transactionsRoot</code></li>
                    <li><code>recieptsRoot</code></li>
                </ul>
                These values represent <b>root hashes</b> that let you traverse
                their respective tries. More on that below.
            </p>
        </details>
        <details>
            <summary>Traversing Modified Merkle-Patricia Tries in LevelDB</summary>
            <p>
                Ethereum uses two kinds of tries to save data in a cryptographically
                secure yet efficient way:
                <ul>
                    <li>Modified Patricia Trie</li>
                    <li>Merkle Trie</li>
                </ul>
                Explaining these trie structures or why Ethereum utilizes them
                is beyond the scope of this tool.
            </p>
            <p>
                These two tries can be constructed from the key/value pairs in the
                DB. The <b>keys</b> in the DB are part of the Merkle trie, while the
                <b>values</b> are part of the Patricia trie.<br>
                Generally speaking, if you are trying to retrieve raw data, you need
                to construct the Patricia trie from the values, but if you are
                trying to validate the data, you need to construct the Merkle trie
                from the keys.
            </p>
            <h4>Example - Retrieving account data</h4>
            <p>
                Let's take block 2,500,039 (<code>2625c7</code> in hex). We can
                get the hash and header data as explained above. From the header
                we can extract the <code>stateRoot</code>, which is:<br>
                <code>644ae129f630e6c5c864b2dbd634c50fe479d631ef76ae1e9ceb5220bca949c5</code>
            </p>
            <p>
                The <code>stateRoot</code> is the <b>key</b> for our root nodes.
                The value stored on this key in the DB is the root Patricia
                node, while the key itself is the root Merkle node.<br>
                Querying this key will give us an RLP-encoded value that
                represents 1 of 4 kinds of Patricia nodes:
                <ul>
                    <li>Empty Node (0 items)</li>
                    <li>Branch Node (17 items)</li>
                    <li>Leaf Node (2 items; value starts with <code>2</code> or <code>3</code>)</li>
                    <li>Extension Node (2 items; value starts with <code>0</code> or <code>1</code>)</li>
                </ul>
            </p>
            <p>
                Querying for our block's <code>stateRoot</code> gives us a
                17-item long <b>branch node</b>. Each item in the branch node
                represents a hex character from <code>0</code> to
                <code>f</code>.<br>
                In order to find the balance of an account in the State Trie, we
                need to traverse the Patricia trie following the keccak256 hash
                of the address we want to query. Let's take the following
                address as an example:<br>
                <code>0x3810d4c7eB88dd66ab9bE39A5F567Cf77fF9f8B7</code><br>
                Its keccak256 value (without the <code>0x</code> part) is:<br>
                <code>acf0daf35759515a3118de4ab5ff63ec27518b94b03d601ac7a1e53b3d6603f8</code><br>
                We need to traverse the Patricia trie for every character in the
                hash. We start from <code>a</code> which is the first character
                in our keccak hash.<br>
                We take the item at index 10 (which is <code>a</code> in hex)
                of the root Patricia node, which is:<br>
                <code>c4ee4cf0cab88b6932d7380a6e0efdc33c1d4f0ffa05207f7a1450b45a97972a</code><br>
                We then query that key to get the next Patricia node. The next
                patricia node is also a branch node, and so we follow it, taking
                the key from the <code>c</code> place in the Patricia branch
                node, which is:<br>
                <code>51f41878a482a7e1a60e91b8e5c66333d119339dc067363b681ad7f7e6581c39</code><br>
                We keep traversing this way, <code>f</code>, <code>0</code>,
                <code>d</code>.<br>
                At this point, we get the next node's <b>key</b>:<br>
                <code>8b97f78fa20cfba908a4953654b4fcdc55c94a3df3305548e1e16eb549c19672</code><br>
                When we query this key, we get a <b>Leaf node</b>. We can
                identify it because if we decode it with RLP, we get 2 items and
                the value of the first item starts with <code>3</code>. This
                type of node is built of two items: the rest of our "path" and
                the final <b>value</b> of our account.<br>
                If we take the first item of this node and remove the
                <code>3</code>, we get:<br>
                <code>af35759515a3118de4ab5ff63ec27518b94b03d601ac7a1e53b3d6603f8</code><br>
                If this string seems familiar, it's because it's part of the
                hash that we were searching for:<br>
                <code>acf0d<b>af35759515a3118de4ab5ff63ec27518b94b03d601ac7a1e53b3d6603f8</b></code><br>
                We traversed through <code>a</code>, <code>c</code>,
                <code>f</code>, <code>0</code>, <code>d</code>, to get to this
                node, which contains the rest of our hash and our desired value
                - 4 items, encoded with RLP, that represent (in order) the
                account data:
                <ol>
                    <li>Nonce</li>
                    <li>Balance</li>
                    <li>storageRoot</li>
                    <li>codeHash</li>
                </ol>
                Looking at the balance, we get <code>b1a2bc2ec50000</code>,
                which converted to decimal becomes
                <code>50000000000000000</code>. This balance is in wei, so it's
                0.05 eth. We can confirm on <a href="https://sepolia.etherscan.io/balancecheck-tool?a=0x3810d4c7eb88dd66ab9be39a5f567cf77ff9f8b7" target=_blank>Etherscan</a> that at block height
                2,500,039, address <code>0x3810d4c7eB88dd66ab9bE39A5F567Cf77fF9f8B7</code>
                had 0.05 eth in its balance.
            </p>
            <p>
                The same technique of traversing the state trie can be used for
                traversing the transactions trie or the receipts trie.
            </p>
        </details>
        <details data-tbd>
            <summary>Contract Storage</summary>
            <p>Coming soon</p>
        </details>
        <details data-tbd>
            <summary>Transactions &amp; receipts</summary>
            <p>Coming soon</p>
        </details>
        <details data-tbd>
            <summary>Logs</summary>
            <p>Coming soon</p>
        </details>
        <main id="notebook">
        </main>
    </body>
</html>
